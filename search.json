[{"title":"Git最佳实践：Git Flow的使用","url":"/archives/a7060461.html","content":"代码管理需要一个清晰的流程和规范\n\n\n\nGit Flow 常用分支\nProduction 分支\n\n也就是我们常用的 master 分支，用来发布到生产环境的代码；这个分支只能从其他分支合并，不能在这个分支直接修改代码。\n\nDevelop 分支\n\n这个分支是我们的主开发分支，包含所有要发布到下一个Release的代码，这个这个合并其他分支，比如Feature分支\n\nFeature 分支\n\n这个分支主要用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release\n\nRelease 分支\n\n当你需要发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并Master和Develop分支\n\nHotfix分支\n\n当我们再Production发现新的Bug时，我们需要创建一个Hotfix，完成Hotfix后，我们合并回master和Develop分支，所以Hotfix的改动会进入下一个Release\nGit Flow如何工作初始分支(master)所有再master分支上的Commit应该Tag\n\nFeature分支分支名feature&#x2F;*\nFeature分支做完后，必须合并回Develop分支，合并完分支后一般会删掉这个Feature分支。\n\nRelease分支分支名release&#x2F;*\nRelease分支基于Develop分支创建，打完Release分支后，我们可以在这个Release分支上测试，修改Bug等。同时，其他开发人员可以基于开发新的Feature发布Release分支时，合并Release到Master和Develop分支，同时在Master分支上打个Tag记住Release版本号，然后就可以删除Release分支了。\n\n维护Hotfix分支名hotfix&#x2F;*\nhotfix分支基于Master分支创建，开发完成后要合并会Master和Develop分支，同时在Master上打一个Tag。\n\nGit Flow代码示例\n创建develop分支\n\ngit branch developgit push -u origin devlop\n\n\n开始新Feature开发\n\ngit checkout -b some-feature develop# Optionally, push branch to origin:git push -u origin some-feature# 做一些改动git statusgit add some-filegit commit\n\n\n完成Feature\n\ngit pull origin developgit checkout developgit merge --no--ff some-featuregit push origin developgit branch -d some-feature# If you pushed branch to origin:git push origin --delete some-feature\n\n\n开始Release\n\ngit checkout -b release-0.1.0 develop# Optional: Bump version number, commit# Prepare release, commit\t\t\n\n\n完成Release\n\ngit checkout mastergit merge --no--ff release-0.1.0git pushgit checkout developgit merge --no--ff release-0.1.0git pushgit branch -d release-0.1.0# If you pushed branch to origin:git push origin --delete release-0.1.0git tag -a v0.1.0 mastergit push --tags\n\n\n开始Hotfix\n\ngit checkout -b hotfix-0.1.1 master\n\n\n完成Hotfix\n\ngit checkout mastergit merge --no--ff hotfix-0.1.1git pushgit checkout developgit merge --no--ff hotfix-0.1.1git pushgit branch -d hotfix-0.1.1git tag -a v0.1.1 mastergit push --tags\n\n[参考大佬]: https://www.cnblogs.com/cnblogsfans/p/5075073.html\t“Git 在团队中的最佳实践–如何正确使用Git Flow”[Origin]: https://nvie.com/posts/a-successful-git-branching-model/\t“A successful Git branching model”\n","categories":["项目实践"],"tags":["Git"]},{"title":"Java & Android代码规范指南","url":"/archives/abf51d21.html","content":"本文为Google Java 风格指南的汉语翻译。无论你是个人开发还是团队协同开发，一个良好的代码规范，能够在项目当中发挥举足轻重的作用；它不仅能使你们的开发更加高效，而且还会减少BUG产生的几率，增强代码可维护性及稳定性。\n遇到不理解的地方，一定要多看看谷歌的Java代码规范官方原文。多思考才能慢慢进步。\n\n\n1 介绍本文档是指导使用 Java 编写源代码的完全定义。 一个 Java 源代码文件只有严格遵守这里的规则，才能被称作为 Google 风格。\n就像其他的编码风格指南，这些问题的覆盖空间不仅涵盖格式化的美学问题，还有一些传统和代码标准。本文档主要着重于通用的 hard-and-fast(确定不可改变的，不可避免，不可忽视) 规则，尽量避免一些非人性化的建议，无论是对人还是工具而言。\n1.1 术语说明在这个文档中，除非有其他的声明：\n\n类是指普通的类、枚举类、接口和注解类型（@Interface）。\n类中的成员可以是成员变量、构造器、方法、内部类，就是类中比较顶层的内容。\n注释总是指具体实现的注释。使用 Javadoc 指代文档注释。\n\n1.2 指南注释本文档中的代码片段只是实现本指南的一种方式，不应该用来直接作为规范。\n2 源文件基础2.1 文件名源文件名由大写敏感的顶层类名和文件扩展 .java组成。\n2.2 编码格式源文件使用UTF-8编码格式。\n2.3 特殊字符2.3.1 空白字符除了行结束符序列，ASCII水平空格字符（0x20，即空格）是源文件中唯一允许出现的空白字符，这意味着：\n\n所有其它字符串中的空白字符都要进行转义。\n制表符不用于缩进。\n\n2.3.2 特殊转义序列对于具有特殊转义序列的任何字符（\\b, \\t, \\n, \\f, \\r, \\&quot;, \\&#39;, //），我们使用它的转义序列，而不是相应的八进制（比如 \\012）或 Unicode（比如\\u000a）转义。\n2.3.3 非ASCII字符对于剩余的非 ASCII 字符，是使用实际的 Unicode 字符（例如， ∞），还是使用等价的 Unicode 转义符（例如，\\u221e），取决于哪个能让代码更易于阅读和理解。\n\n在使用 Unicode 转义符或是一些实际的 Unicode 字符时，建议做些注释给出解释，这有助于别人阅读和理解。\n\n\n\n\nExample\nDiscussion\n\n\n\nString unitAbbrev &#x3D; “μs”;\nBest: perfectly clear even without a comment.\n\n\nString unitAbbrev &#x3D; “\\u03bcs”; &#x2F;&#x2F; “μs”\nAllowed, but there’s no reason to do this.\n\n\nString unitAbbrev &#x3D; “\\u03bcs”; &#x2F;&#x2F; Greek letter mu, “s”\nAllowed, but awkward and prone to mistakes.\n\n\nString unitAbbrev &#x3D; “\\u03bcs”;\nPoor: the reader has no idea what this is.\n\n\nreturn ‘\\ufeff’ + content; &#x2F;&#x2F; byte order mark\nGood: use escapes for non-printable characters, and comment if necessary.\n\n\n\n永远不要因为害怕某些程序可能无法正确处理非 ASCII 字符而让你的代码可读性变差。当程序无法正确处理非ASCII字符时，自然无法正确运行， 然后必须去解决这些问题就好了。\n\n3 源文件结构一个源文件包含（按顺序地）：\n\n许可证或版权信息（如有）\nPackage 语句\nImport 语句\n有且仅有一个顶级类\n\n以上每个部分之间用一个空行隔开。\n3.1 许可证或版权信息（如有）如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。\n3.2 package语句Package 语句不会自动换行，列限制（4.4节，列限制：100 ）并不适用于 Package 语句（即 Package 语句写在一行里）。\n3.3 import语句3.3.1 import不要使用通配符不要出现类似这样的 Import 语句：import java.util.*;\n3.3.2 不要换行Import 语句不换行，列限制（4.4节，列限制：100 ）并不适用于 Import 语句（即 Import 语句写在一行里）。\n3.3.3 顺序和间距Import 语句按照以下规则排序：\n\n所有静态导入独立成块\n所有非静态导入独立成块\n\n如果静态块和非静态块同时存在，用一个空行分隔。Import语句之间不会有多余的空行。\n每个导入块之间的排列顺序按照 ASCII 排序。\n3.3.4 不要使用静态导入的类静态导入不适用静态内部类。他们要使用正常导入。\n3.4 类声明3.4.1 只有一个顶级类声明每个顶级类都在一个与它同名的源文件中(当然，还包含.java后缀)。例外，package-info.java，该文件中可没有package-info类。\n3.4.2 类成员顺序类的成员顺序对易学性有很大的影响，但这也不存在唯一的通用法则。不同的类对成员的排序可能是不同的。\n最重要的一点，每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑。比如， 新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。\n3.4.2.1 重载：永不分离当一个类有多个构造函数，或是多个同名方法，这些函数&#x2F;方法应该按顺序出现在一起，中间不要放进其它函数&#x2F;方法。不受修饰符的影响。\n4 格式化术语说明：块状结构指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构（4.8.3.1节）。\n4.1 大括号4.1.1 使用大括号(即使是可选的)大括号与 if, else, for, do, while 语句一起使用，即使只有一条语句(或是空)，也应该把大括号写上。\n其他的可选择大括号，例如 lambda 表达式中，保留可选择性。\n4.1.2 非空块：K &amp; R 风格对于非空块和块状结构，大括号遵循 Kernighan 和 Ritchie 风格（Egyptian brackets）：\n\n左大括号前不换行\n左大括号后换行\n右大括号前换行\n如果右大括号是一个语句、函数体或类的终止，则右大括号后换行; 否则不换行。例如，如果右大括号后面是else或逗号，则不换行。 例如，\n\nreturn () -&gt; &#123;  while (condition()) &#123;    method();  &#125;&#125;;return new MyClass() &#123;  @Override public void method() &#123;    if (condition()) &#123;      try &#123;        something();      &#125; catch (ProblemException e) &#123;        recover();      &#125;    &#125; else if (otherCondition()) &#123;      somethingElse();    &#125; else &#123;      lastThing();    &#125;    &#123;      int x = foo();      frob(x);    &#125;  &#125;&#125;;\n\n\n4.8.1节给出了enum类的一些例外。\n\n4.1.3 空块：可以用简洁版本一个空的块状结构里什么也不包含，大括号可以简洁地写成{}，不需要换行。例外：如果它是一个多块语句的一部分（例如，if/else 或 try/catch/finally），即使大括号内没内容，右大括号也要换行。 例如，\n// This is acceptablevoid doNothing() &#123;&#125;// This is equally acceptablevoid doNothingElse() &#123;&#125;\n\n// This is not acceptable: No concise empty blocks in a multi-block statementtry &#123;  doSomething();&#125; catch (Exception e) &#123;&#125;\n\n4.2 块缩进：2个空格每当开始一个新的块，缩进增加2个空格，当块结束时，缩进返回先前的缩进级别。缩进级别适用于代码和注释。（见4.1.2节中的代码示例）\n4.3 一行一个语句每个语句后要换行。\n4.4 列限制：100一个项目可以选择一行100个字符的列限制，除了下述例外，任何一行如果超过这个字符数限制，必须自动换行。例外：\n\n不可能满足列限制的行（例如，Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考）。\nPackage 和 Import 语句(见3.2节和3.3节)。\n注释中那些可能被剪切并粘贴到 shell 中的命令行。\n非常长的标识符。\n\n4.5 自动换行术语说明：代码否则已经要合法的占据一整行的情况下，这段代码就会被分成多行。这个活动称之为自动换行（line-wrapping）。我们并没有全面，确定性的准则来决定在每一种情况下如何自动换行。很多时候，对于同一段代码会有好几种有效的自动换行方式。\n\n提取方法或局部变量可以在不换行的情况下解决代码过长的问题(是合理缩短命名长度吧)\n\n4.5.1 从哪里断开自动换行的基本准则是：更倾向于在更高的语法级别处断开。\n\n如果在非赋值运算符处断开，那么在该符号前断开(比如+，它将位于下一行)。注意：这一点与Google其它语言的编程风格不同(如C++和JavaScript)。 这条规则也适用于以下“类运算符”符号：\n\n点分隔符（.）\n方法引用（::）\n类型界限中的 &amp;（&lt;T extends Foo &amp; Bar&gt;）\ncatch 块中的管道符号（catch (FooException | BarException e)）\n\n\n如果在赋值运算符处断开，通常的做法是在该符号后断开(比如&#x3D;，它与前面的内容留在同一行)。\n\n这条规则也适用于foreach语句中的分号。\n\n\n方法名或构造函数名与左括号留在同一行。\n\n逗号（,）与其前面的内容留在同一行。\n\nlambda 箭头后不允许换行，除非后面跟着一个单语句。例如，\nMyLambda&lt;String, Long, Object&gt; lambda =    (String label, Long value, Object obj) -&gt; &#123;        ...    &#125;;Predicate&lt;String&gt; predicate = str -&gt;    longExpressionInvolving(str);\n\n4.5.2 自动换行时缩进至少+4个空格自动换行时，第一行后的每一行至少比第一行多缩进4个空格（注意：制表符不用于缩进。见2.3.1节）。当存在连续自动换行时，缩进可能会多缩进不只4个空格（语法元素存在多级时）。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。第4.6.3节水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。\n4.6 空白4.6.1 垂直空白以下情况需要使用一个空行：\n\n类内连续的成员之间：字段，构造函数，方法，嵌套类，静态初始化块，实例初始化块。\n例外：两个连续字段之间的空行是可选的，用于字段的空行主要用来对字段进行逻辑分组。\n例外：枚举常量之间的空行见4.8.1节。\n\n\n要满足本文档中其他节的空行要求(比如，3节：源码文件结构，3.3节：import语句)\n\n一个单独的空行可以出现在任何地方，只要它能够改善源码的可读性，例如，在语句中间加空行整理代码，让代码变成逻辑上的子集合。一个空行出现在第一个成员或者初始化器之前，或者在最后一个成员或者初始化器之后，既不鼓励也不抨击这样的行为。\n多个连续的空行是允许的，但没有必要这样做（我们也不鼓励这样做）。\n4.6.2 水平空白除了语言需求和其它规则，并且除了文字，注释和 Javadoc 用到单个空格，单个 ASCII 空格也出现在以下几个地方：\n\n分隔任何保留字与紧随其后的左括号（(），比如，if，for，或者 catch。\n\n分隔任何保留字与其前面的右大括号（&#125;），比如，else，catch。\n\n在任何左大括号前（&#123;），两个例外：\n\n@SomeAnnotation(&#123;a, b&#125;)（不使用空格）\nString[][] x = &#123;&#123;\"foo\"&#125;&#125;;（括号间没有空格，见下面的）\n\n\n在任何二元或三元运算符的两侧。这也适用于以下“类运算符”符号：\n\n类型界限连接中的 &amp;（&lt;T extends Foo &amp; Bar&gt;）\ncatch块中的管道符号| catch (FooException | BarException e)\n增强 for 语句（foreach）语句中的分号（:）。\nlambda 表达式中的箭头符号：(String str) -&gt; str.length()\n\n不适用于：\n\n双引号（::）的方法引用，写法例如：Object::toString\n点分割符号（.），写法例如：object.toString()\n\n\n在 , : ; 及转型的右括号（(）后\n\n在任何内容和双斜杠（//）之间，双斜杠之后就是注释。允许多个空格。\n\n在双斜杠（//）和注释之间。允许多个空格。\n\n声明时，在类型和变量之间：List&lt;String&gt; list\n\n数组初始化中，大括号内的空格是可选的\n\nnew int[] &#123;5, 6&#125; 和 new int[] &#123; 5, 6 &#125; 都是有效的\n\n\n在类型注解和 [] 、... 之间。 （我也不知道他这个时什么意思，先相信）\n\n\n这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。\n4.6.3 水平对齐：不做要求术语说明：水平对齐指的是通过增加可变数量的空格来使某一行的字符与上一行的相应字符对齐。这是允许的(而且在不少地方可以看到这样的代码)，但Google编程风格对此不做要求。即使对于已经使用水平对齐的代码，我们也不需要去保持这种风格。以下示例先展示未对齐的代码，然后是对齐的代码：\nprivate int x; // this is fineprivate Color color; // this tooprivate int   x;      // permitted, but future editsprivate Color color;  // may leave it unaligned\n\n\n对齐可增加代码可读性，但它为日后的维护带来问题。考虑未来某个时候，我们需要修改一堆对齐的代码中的一行。 这可能导致原本很漂亮的对齐代码变得错位。很可能它会提示你调整周围代码的空白来使这一堆代码重新水平对齐(比如程序员想保持这种水平对齐的风格)， 这就会让你做许多的无用功，增加了reviewer的工作并且可能导致更多的合并冲突。\n\n4.7 用小括号来限定组：推荐除非作者和 reviewer 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。 我们没有理由假设读者能记住整个Java运算符优先级表。\n4.8 特定结构4.8.1 枚举类枚举常量间用逗号隔开，换行可选。额外的空行（通常只有一个）也是被允许的。例如：\nprivate enum Answer &#123;  YES &#123;    @Override public String toString() &#123;      return &quot;yes&quot;;    &#125;  &#125;,  NO,  MAYBE&#125;\n\n没有方法和文档的枚举类可写成数组初始化的格式（见4.8.3.1节，数组初始化）：\nprivate enum Suit &#123; CLUBS, HEARTS, SPADES, DIAMONDS &#125;\n\n由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。\n4.8.2 变量声明4.8.2.1 每次只声明一个变量不论成员还是局部变量，每次只声明一个变量，不要使用组合声明：声明比如：int a, b; 是不被允许的。\n例外情况：多变量声明在 for 循环头部是可接受的。\n4.8.2.2 需要时才声明，并尽快进行初始化不要在一个代码块的开头把局部变量一次性都声明了，而是在第一次需要使用它时才声明，减小他们的范围。 局部变量最好在声明时就进行初始化，或者声明后尽快进行初始化。\n4.8.3 数组4.8.3.1 数组初始化：可写成块状结构数组初始化可以写成块状结构，比如，下面的写法都是有效的：\nnew int[] &#123;  0, 1, 2, 3&#125;new int[] &#123;  0,  1,  2,  3&#125;new int[] &#123;  0, 1,  2, 3&#125;new int[]    &#123;0, 1, 2, 3&#125;\n\n4.8.3.2 非C风格的数组声明中括号是类型的一部分：String[] args，而非 String args[]。\n4.8.4 switch语句术语说明：switch块的大括号内是一个或多个语句组。每个语句组包含一个或多个 switch 标签（case FOO:或default:），后面跟着一条或多条语句。\n4.8.4.1 缩进与其它块状结构一致，switch 块中的内容缩进为2个空格。 每个 switch 标签后新起一行，再缩进2个空格，写下一条或多条语句。\n4.8.4.2 Fall-through：注释在一个switch块内，每个语句组要么通过 break，continue，return 或抛出异常来终止，要么通过一条注释来说明程序将继续执行到下一个语句组， 任何能表达这个意思的注释都是足够的（典型的是用 // fall through）。这个特殊的注释并不需要在最后一个语句组（一般是 default）中出现。示例：\nswitch (input) &#123;  case 1:  case 2:    prepareOneOrTwo();    // fall through  case 3:    handleOneTwoOrThree();    break;  default:    handleLargeNumber(input);&#125;\n\n注意一下，case 1 后面不需要注释，只有在每个语句组的结尾才需要。\n4.8.4.3 default 存在的情况每个 switch 语句都包含一个 default 语句组，即使它什么代码也不包含。\n例外情况：枚举类型的 switch 语句可以省略 default 语句组，如果已经详细列出了它的所有可能。这将保证 IDE 代码检测工具不会报警报。\n4.8.5 注解4.8.5.1 类型使用注解类型使用立即出现在被注解的类型之前。一个注解是类型使用的是指它的元注解是 @Target(ElementType.TYPE_USE)。例如：\nfinal @Nullable String name;public @Nullable Person getPersonByName(String name);\n\n4.8.5.2 类注解类注解立即出现在文档块之后，每一个注解都单独成行，也就是注解行。这些换行不属于自动换行（4.5节，Line-Wrapping），所以缩进等级不会提高。例如：\n@Deprecated@CheckReturnValuepublic final class Frozzler &#123; ... &#125;\n\n4.8.5.3 方法和构造器注解使用方法同上节。例如：\n@Override@Nullablepublic String getNameIfPresent() &#123; ... &#125;\n\n例外情况：单个无参数的注解可以和签名的第一行出现在一起。例如：\n@Override public int hashCode() &#123; ... &#125;\n\n4.8.5.4 字段注解应用于字段的注解紧随文档块出现，应用于字段的多个注解允许与字段出现在同一行。例如：\n@Partial @Mock DataLoader loader;\n\n4.8.5.5 参数和局部变量的注解参数和局部变量注解没有特定规则（除非这个注解是类型使用注解）。\n4.8.6 注释本节重点在于代码注释的实现。Javadoc 相关见7节，Javadoc。\n4.8.6.1 块注释风格块注释与其周围的代码在同一缩进级别。它们可以是 /* ... */ 风格，也可以是 // ... 风格。对于多行的 /* ... */ 注释，后续行必须从 * 开始， 并且与前一行的 * 对齐。例如：\n/* * This is          // And so           /* Or you can * okay.            // is this.          * even do this. */ */\n\n不能再注释里面写注释。\n\n小贴士：多行注释使用 /* ... */ 风格，这样格式化的时候会自动换行。大多数的格式化插件下，单行注释 // ... 块不会自动换行。\n\n4.8.7 Modifiers类和成员的 **modifiers如果存在，则按Java语言规范中推荐的顺序出现。\npublic protected private abstract default static final transient volatile synchronized native strictfp\n\n4.8.8 数字字义long 值的整型字义使用大写的 L 后缀，永远不要使用小写 l。例如，300000000000L 而不是 300000000000l。\n5 命名5.1 对所有标识符都通用的规则标识符只能使用ASCII字母和数字,在如下极少数情况下使用下划线。因此每个有效的标识符名称都能匹配正则表达式\\w+。在 Google 风格中，特殊前缀和后缀不再使用。例如，这些命名都不是 Google 风格：name_, mName(这个Android 成员变量好像一直在用233), s_name和kName。\n5.2 标识符类型的规则5.2.1 包名包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：com.example.deepspace, 不是 com.example.deepSpac 或者 com.example.deep_space。\n5.2.2 类名类名都以 UpperCamelCase 风格编写。类名通常是名词或名词短语。例如：Character 或者 ImmutableList 。接口名可以也是名词或名词性短语;例如：List；但有时可能是形容词或形容词短语，例如：Readable。\n现在还没有特定的规则或行之有效的约定来命名注解类型。测试类名以 Test 结束,例如，HashIntegrationTest。如果要测试的是一个单类，命名就要用单类名加上 Test，例如，HashImplTest。\n5.2.3 方法名方法名使用 lowerCamelCase 风格编写。方法名通常是动词或动词短语。例如：sendMessage 或者 stop。下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件，其中每个组件都要使用 lowerCamelCase，例如，transforMoney_deductsFromSource 。测试方法命名不止 一种正确方式。\n5.2.4 常量名常量名命名使用 UPPER_SNAKE_CASE：全部字母大写，用下划线分隔单词。那，到底什么算是一个常量？常量都是 静态 final 字段，其内容都是深度不可变的，其包含的方法不会有任何可检测的副作用。例如：primitives，字符串，值不可变的类，或者是任何设置成 null 的变量。如果任何一个实例的可观测状态是可变的，那它就不是一个常量。仅仅只是意图永远不去改变一个对象是不够的。例如：\n// Constantsstatic final int NUMBER = 5;static final ImmutableList&lt;String&gt; NAMES = ImmutableList.of(&quot;Ed&quot;, &quot;Ann&quot;);static final Map&lt;String, Integer&gt; AGES = ImmutableMap.of(&quot;Ed&quot;, 35, &quot;Ann&quot;, 32);static final Joiner COMMA_JOINER = Joiner.on(&#x27;,&#x27;);  // because Joiner is immutablestatic final SomeMutableType[] EMPTY_ARRAY = &#123;&#125;;// Not constantsstatic String nonFinal = &quot;non-final&quot;;final String nonStatic = &quot;non-static&quot;;static final Set&lt;String&gt; mutableCollection = new HashSet&lt;String&gt;();static final ImmutableSet&lt;SomeMutableType&gt; mutableElements = ImmutableSet.of(mutable);static final Logger logger = Logger.getLogger(MyClass.getName());static final String[] nonEmptyArray = &#123;&quot;these&quot;, &quot;can&quot;, &quot;change&quot;&#125;;\n\n这些名字通常是名词或名词短语。\n5.2.5 非常量字段名非常量字段名（静态或其他）使用 lowerCamelCase 风格编写。这些名字通常是名词或名词短语。例如，computeValues 或者 index。\n5.2.6 参数名参数名使用 lowerCamelCase 风格编写。参数应该避免用单个字符命名。\n5.2.7 局部变量名局部变量名使用 lowerCamelCase 风格编写，比起其它类型的名称，局部变量名可以有更为宽松的缩写。即使局部变量是final和不可改变的，也不应该把它示为常量，自然也不能用常量的规则去命名它。\n5.2.8 类型变量名类型变量可用以下两种风格之一进行命名：\n\n单个的大写字母，后面可以跟一个数字(例如：E, T, X, T2)。\n以类命名方式（见5.2.2节），后面加个大写的 T（例如：RequestT, FooBarT）。\n\n5.3 驼峰式命名法(CamelCase)驼峰式命名法分大驼峰式命名法（UpperCamelCase）和小驼峰式命名法（lowerCamelCase）。 有时，有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构，例如，IPv6 或 iOS。为了改善可预测性，Google 风格指定了以下近乎确定的方案。\n名字从散文形式(prose form)开始:\n\n把短语转换为纯ASCII码，并且移除任何所有格符号。例如，&quot;Müller’s algorithm 将变成 Muellers algorithm。\n\n把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。\n\n推荐：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开（如 AdWords 将分割成 ad words）。 需要注意的是 iOS 并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。\n\n\n现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：\n\n每个单词的第一个字母都大写，来得到大驼峰式命名。\n\n除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。\n\n\n\n最后将所有的单词连接起来得到一个标识符。\n\n\n例如：\n\n\n\nProse form\nCorrect\nIncorrect\n\n\n\n“XML HTTP request”\nXmlHttpRequest\nXMLHTTPRequest\n\n\n“new customer ID”\nnewCustomerId\nnewCustomerID\n\n\n“inner stopwatch”\ninnerStopwatch\ninnerStopWatch\n\n\n“supports IPv6 on iOS?”\nsupportsIpv6OnIos\nsupportsIPv6OnIOS\n\n\nYouTube importer”\nYouTubeImporter  YoutubeImporter*\n\n\n\n加星号处表示可以接受，但不推荐。\n\n小贴士：有些单词在英语中被隐式的连字符连接起来。例如，nonempty 和 non-empty 都是正确的，所以方法名 checkNonempty 和 checkNonEmpty 两者同样都是正确的。\n\n6 编程实践6.1 @Override：总是使用只要是合法的，就把@Override注解给用上。包括负载的父类方法，实现的接口方法，接口中继承父类接口的方法。\n例外：@override 在父类方法被标注为 @Deprecated 时是可以被忽略不写的。\n6.2 捕获的异常：不能忽视除了下面的例子，对捕获的异常不做响应是极少正确的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 AssertionError 重新抛出。) 如果它确实是不需要在catch块中做任何响应，需要做注释加以说明(如下面的例子)。\ntry &#123;  int i = Integer.parseInt(response);  return handleNumericResponse(i);&#125; catch (NumberFormatException ok) &#123;  // it&#x27;s not numeric; that&#x27;s fine, just continue&#125;return handleTextResponse(response);\n\n例外：在测试中，如果一个捕获的异常被命名为 expected，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。\ntry &#123;  emptyStack.pop();  fail();&#125; catch (NoSuchElementException expected) &#123;&#125;\n\n6.3 静态成员：使用类授权调用如果一个静态类的引用一定要授权，那么使用类名授权，即使用类名调用静态的类成员，而不是具体某个对象或返回对象的表达式。\nFoo aFoo = ...;Foo.aStaticMethod(); // goodaFoo.aStaticMethod(); // badsomethingThatYieldsAFoo().aStaticMethod(); // very bad\n\n6.4 Finalizers: 禁用极少会去重载 Object.finalize。\n\n不要使用 finalize。如果你非要使用它，请先仔细阅读和理解 Effective Java 第7条款：Avoid Finalizers，然后不要使用它。\n\n7 Javadoc7.1 格式7.1.1 一般形式Javadoc 块的基本格式如下所示：\n /** * Multiple lines of Javadoc text are written here, * wrapped normally... */public int method(String p1) &#123; ... &#125;\n\n或者是以下单行形式：\n/** An especially short bit of Javadoc. */\n\n基本格式总是能接受的。当整个 Javadoc 块能容纳于一行时(包括注释标注)，可以使用单行形式。注意，这仅仅适用于没有 Javadoc 标记 @XXX 的情况，例如： @return。\n7.1.2 段落空行(即只包含最左侧星号(*)的行)会出现在段落之间和 Javadoc 标记( @XXX )(如果有的话)之前。 除了第一个段落，每个段落第一个单词前都有标签 &lt;p&gt;，并且它和第一个单词间没有空格。其他块级元素的 HTML 标签前面不用加 &lt;p&gt;, 例如：&lt;ul&gt; 或者 &lt;table&gt;。\n7.1.3 块标签标准的块标签按以下顺序出现：@param,  @return, @throws, @deprecated, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少在 @ 再缩进4个空格。e.g.:\n/** * Called when the activity is starting.  This is where most initialization * should go: calling &#123;@link #setContentView(int)&#125; to inflate the * activity&#x27;s UI, using &#123;@link #findViewById&#125; to programmatically interact * with widgets in the UI, calling * &#123;@link #managedQuery(android.net.Uri , String[], String, String[], String)&#125; to retrieve * cursors for data being displayed, etc. * * &lt;p&gt;You can call &#123;@link #finish&#125; from within this function, in * which case onDestroy() will be immediately called after &#123;@link #onCreate&#125; without any of the * rest of the activity lifecycle (&#123;@link #onStart&#125;, &#123;@link #onResume&#125;, &#123;@link #onPause&#125;, etc) * executing. * * &lt;p&gt;&lt;em&gt;Derived classes must call through to the super class&#x27;s * implementation of this method.  If they do not, an exception will be * thrown.&lt;/em&gt;&lt;/p&gt; * * @param savedInstanceState If the activity is being re-initialized after *     previously being shut down then this Bundle contains the data it most *     recently supplied in &#123;@link #onSaveInstanceState&#125;.  &lt;b&gt;&lt;i&gt;Note: Otherwise it is null.&lt;/i&gt;&lt;/b&gt; * * @see #onStart * @see #onSaveInstanceState * @see #onRestoreInstanceState * @see #onPostCreate */\n\n7.1.4 配置外链在注释中使用&lt;a&gt;标签配置外链；可配置新标签页打开，添加target=&quot;_blank&quot;属性：\n/** * 打开 H5 外链 * @param param h5 传参 @see &lt;a href=&quot;https://www.wolffy233.fun/&quot; target=&quot;_blank&quot;&gt;灰太狼大王&lt;/a&gt; * @param context 上下文 */\n\n7.2 摘要片段每个 Javadoc 块以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，比如在类和方法索引中，它是唯一出现的文本。\n这就是一个片段，可以是一个名词短语或动词短语，不是一个完整的句子。它不会以 A &#123;@code Foo&#125; is a... 或 This method returns... 开头, 它也不会是一个完整的祈使句，如 Save the record...。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。\n\n小贴士：一个常见的错误是把简单的Javadoc写成 /** @return the customer ID */，这是不正确的。它应该写成 /** Returns the customer ID. */。\n\n7.3 哪里需要使用Javadoc至少在每个 public 类及它的每个 public 和 protected 成员上使用Javadoc，以下是一些例外：\n额外的 Javadoc 内容也可以展示，7.3.3 章节会解释。\n7.3.1 例外：不言自明的方法对于简单明显的成员如 getFoo()， Javadoc 是可选的。这种情况下除了写 Returns the foo，确实也没有什么值得写了。 单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。\n\n重要小贴士：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名getCanonicalName， 就不应该忽视文档说明，因为读者很可能不知道词语canonical name指的是什么。\n\n7.3.2 例外：重载如果一个方法重载了超类中的方法，那么 Javadoc 并非必需的。\n7.3.3 非必需Javadoc其他的类或者成员已经有了需要的 Javadoc。\n非必需 Javadoc 不需要严格遵守 7.1.1 7.1.2 7.1.3 和 7.2 的格式化规则，尽管我们的建议还是按照规则来做。\n8 Android部分8.1 代码命名规则\nActivity 命名一律使用 功能名+Activity 的方式。例如：LoginActivity、SignupActivity。\n\nFragment 命名一律使用 功能名+Fragment 的方式。例如：HomeFragment、MineFragment。\n\n自定义View：**Custom(建议)+功能名+View&#x2F;ViewGroup(具体的组件名称)**。例如：CustomImageScroller、CustomRatingBar。\n\nWidget 命名一律使用 功能名 + Widget。例如： ScanWidget、WeatherWidget。\n\nDialog 对话框：功能名+Dialog。例如：LoginDialog、ProgressDialog。\n\n尽量在每一个Activity或类中加入TAG,方便我们查看Activity的信息\n\nTip : 使用Android Studio提供的快捷键logt可快速生成当前 类的常量)。\n\n\n对于使用Intent传递数据，声明一些 Key 的时候：\n\nEXTRA_KEY_+具体Key名称，例如我们现在有一个人的名字和年龄要传那么首先定义：\n\n\n\npublic static final String EXTRA_KEY_PERSON_NAME=&quot;EXTRA_KEY_PERSON_NAME&quot;public static final String EXTRA_KEY_PERSON_AGE=&quot;EXTRA_KEY_PERSON_AGE&quot;\n\n然后在具体的页面 new Intent()，依次传递进去值，这样写其实没什么问题；但是试想一下，如果你要调用的Activity是类似于一个工具性质或通用的 Activity（图片选择器、登录、注册等等），这时候你要传递的 Key 又很多，如果业务复杂的话，你应该会被这样冗余且不易阅读的代码直接搞崩溃掉。\n所以最好的办法就是在你要调用Activity提供一个静态工厂方法，要知道静态工厂方法所带来的好处太多了，由于 Activity 是不允许通过 new 的方式来初始化的，所以静态工厂方法的好处在此就不那么明显，但是已经足够我们优化我们的代码了。举个例子，我们有一个笔记 NoteActivity，用于创建笔记和修改笔记，\n//笔记Idprivate static final String EXTRA_KEY_NOTE_ID =&quot;EXTRA_KEY_NOTE_ID&quot; ;//笔记内容private static final String EXTRA_KEY_NOTE_CONTENT =&quot;EXTRA_KEY_NOTE_CONTENT&quot; ;//笔记模式private static final String EXTRA_KEY_NOTE_MODE =&quot;EXTRA_KEY_NOTE_MODE&quot; ;//用于创建笔记public static void startForCreate(Context context, int noteId) &#123;  start(context, noteId, null, MODE_CREATE);&#125;    //用于编辑笔记public static void startForEdit(Context context, int noteId, String content) &#123;  start(context, noteId, content, MODE_UPDATE);&#125;public static void start(Context context, int noteId, String content, int mode) &#123;  Intent starter = new Intent(context, TableShareListSettingActivity.class);  starter.putExtra(EXTRA_KEY_NOTE_ID,noteId);  starter.putExtra(EXTRA_KEY_NOTE_CONTENT,content);  starter.putExtra(EXTRA_KEY_NOTE_CONTENT,mode);  context.startActivity(starter);&#125;\n\n通过以上方法，我们能够很好的解耦复杂的 Activity 之间的调用，再加上静态方法工厂方法名，代码可阅读行大大提高，最终我们看到的调用 NoteActivity 将会是很简洁的一段代码：\nNoteActivity.startForCreate(this,noteId);NoteActivity.startForEdit(this,noteId,content);\n\n此外，Android Studio 工具中其实已经在 Live Template 中提供了这样的代码: CMD+J( For MAC OS) ,简单的输入starter就可以快速地在当前的Activity中添加一个 Intent 的静态操作方法，这其实也说明了 Android 官方团队也鼓励我们这么做。\n\nActivity 中变量采用m开头+类名。例如，mTable、mPerson；\nActivity中的控件：m + 控件类型名称缩写 + 模块名。例如，mEtLogin,mTvLogin;\n\n8.2 资源 Res按照资源的类型，分为以下几种:\n8.2.1 控件Id命名控件缩写 _模块（module) _功能名(function)\n控件类型         ID命名规则TextView tv_module_functionEditText et_module_functionImageView iv_module_functionButton         btn_module_functionListView lv_module_functionGridView gv_module_functionCheckBox check_module_functionRadioButton radio_module_functionLinearLayout ll_module_functionRelativeLayout  rl_module_functionFrameLayout fl_module_functionGridLayout gl_module_function\n\n8.2.2 Color资源命名Resources Type 命名规则color 组件名+模块名+具体作用名。例 R.color.login_button_text\n\n8.2.3 String资源命名Resources Type 命名规则string 模块名+具体功能。 例 R.string.login_hello\n\n8.2.4 Drawable资源命名Resources Type 命名规则launcher icon ic_launcher。例R.drawable.ic_launchernormal icon 具体模块_ic_功能。例R.drawable.ic_audio_pauseToolbar icon 具体模块_ic_tb_功能名。例如login_ic_tb_searchselector selector_模块_功能名。例如 selector_login_buttonshape shape_模块功能名状态。例如 R.drawable.shape_login_button_normal\n\n8.2.5 Layout资源命名类型 命名规则activity activity_功能名。例如 R.layout.activity_loginfragment fragment_功能名。例如 R.layout.fragment_login_layout_headerinclude layout_模块名_功能名。例如 @layout/layout_login_bottomadapter adapter_item_模块名_功能名。例如 R.layout.adapter_item_simple_textdialog dialog_模块_功能名。例如 R.layout.dialog_time_pickerlist header header_模块_功能。例如 R.layout.header_login_top_adlist footer footer_模块_功能。例如 R.layout.footer_login_bottom_actionwidget widget_模块_功能。例如 R.layout.widget_login_clock\n\n8.2.6 Menu资源命名Resources Type 命名规则menu menu_模块名。例如 menu_login\n\n8.2.7 Values资源命名Resources Type 命名规则color 模块名_color。例如 material_design_colordimens 模块名_dimens。例如 material_design_dimensstyle 模块名_style。例如 material_design_stylethemes 模块名_themes。例如 material_design_themes\n\n参考资料","categories":["项目实践"],"tags":["Code Style"]},{"title":"UML工具学习使用","url":"/archives/66a645ce.html","content":"让开发过程清晰，提高做项目的能力和效率。**UML(Unified Modeling Language)** 可以应用在需求分析，设计分析，开发，维护阶段。\n\n\nUML的使用场景\n需求分析：用例图分析系统交互，类图描述核心类，活动图描述协作，状态图描述状态转移过程；\n设计分析：类图描述软件开发中的类，时序图描述交互场景，包图描述模块间的关系，状态图描述类的生命周期，部署图描述物理服务器关系；\n文档记录：方便开发梳理逻辑\n\n"},{"title":"LOL下路辅助专精","url":"/archives/8a05937c.html","content":"自家用游戏技巧！HAPPY GAME, HAPPY LIFE～\n\n\n输入游戏输入内容\n外设有点后悔，当时主机上华硕的配件应该更合适 o ^ o\n\n主机：\n微星（MSI）MAG B660M MORTAR  WIFI DDR4 迫击炮电脑主板\n微星（MSI）超龙X GeForce RTX 3070 Ti SUPRIM X 8G\n英特尔（Intel） i7-12700KF 12核 20线程 睿频至高可达 5.0GHz 25M三级缓存 台式机CPU\n\n\n显示器：飞利浦 27英寸 2k&#x2F;QHD IPS技术\n键盘：雷蛇（Razer）黑寡妇蜘蛛 V3 竞技版 机械键盘 87 键 黄轴\n鼠标：雷蛇（Razer）炼狱蝰蛇 V3 游戏鼠标 人体工学设计\n鼠标垫：雷蛇（Razer）重装甲虫 V3-M 号\n耳机：雷蛇（Razer）北海巨妖V3 超感版\n\n双手锻炼大脑和手指灵活度\n左手用于控制键盘\n\n大拇指控制 ALT 仅 1 个键\n食指控制 F3 F4 F5 3 4 5 6 7 E R T P D F G H C V B 共 19 个键\n中指控制 F2 2 W O S X 共 6 个键\n无名指控制 ESC F1 &#96; 1 TAB Q CAP LOCK A SHIFT Z CTRL 共 11 个键\n\n可见理想情况下，左手在游戏中共控制 1 + 19 + 6 + 11 &#x3D; 37 个键\n右手用于控制鼠标\n\n食指控制鼠标左键，用于配合左手 A 键使用，主要用于攻击\n中指控制鼠标右键，主要用于走位\n\n操作有感20250507最近在看 LCK 比赛集锦，HLE VS NS 的第一把比赛中神王宙斯的杰斯发挥太亮眼了，反复观看后发现宙斯的操作习惯，鼠标右键走位频率特别频繁，而且鼠标位置距离英雄自身特别近，这样英雄反应尤为灵敏，当近身肉搏时宙斯选择右键攻击敌人，拉开距离后使用 A 攻击敌人，挺合理的，学习学习。\n感觉今天有点小开悟，外界规则是固定的，转换思路，灵活认知，不要钻牛角尖，要灵活，i.e. 键盘的 F J 键一般用于定位，但是目前的键位习惯看似用不上，转换一下思路，可以先用两个食指找到这两个定位键，然后再移位不就好了，就是这么简单，为啥要纠结这些东西这么久～还有就是无论发生什么都不要责怪自己，自怨自艾，这样子抱怨自己解决不了任何问题，只会消耗自己能量。想起之前的一次经历，玩卡莎的时候残血觉得没希望了，脑子里有了要被击杀的想法，但是心里不想被击杀就一直A对面还真把对面近乎满血的AD击杀了，只记得当时觉得A不出来了，但是确实A了好多下，那种感觉很棒，那段时间AD玩的很棒，后面忘了这种感觉玩的就又拉胯了，现在记录下，无事的时候可以回味一下233\n英雄韦鲁斯VIPER 丛刃穿甲玩法，有一套连招很丝滑 A A Q A R E W Q 赏心悦目，牛逼～\n卡莎poke 流装备：电暗卢电刀可以替换 AP 装，暗影阔剑可以替换狂妄&#x2F;魔宗\n女枪幽梦，三速鞋转火炮无尽\\大穿，防装饮血剑；鞋子大后期换狂妄\n烬锯齿短匕，三速鞋，合成幽梦转火炮无尽\\大穿，防装复活天使&#x2F;大饮魔刀；鞋子大后期换狂妄\n","categories":["英雄联盟"],"tags":["下路辅助"]},{"title":"从安卓手机中拉出Apk","url":"/archives/6f7bfefe.html","content":"如何快速将安装到手机中的应用的Apk文件快速拿出来，使用下面几个ADB命令即可轻松做到。\n\n\n查看是否链接到手机adb devices\n\n\n进入手机的shell层\n单一设备链接时\n\nadb shell\n\n\n\n多设备链接时\n\nadb -s 手机设备序列号 shell\n\n\n查看安装软件的包名\n查看所有软件的包名\n\npm list packages\n\n\n\n根据关键字查找包名\n\npm list packages | grep oneplus\n\n\n查看安装包的位置\n查看所有安装包位置\n\n pm list packages -f\n\n\n\n查看符合包名要求的安装包位置\n\npm list packages -f | grep tencent\n\n\n将Apk拉到PC本地exitadb pull 上一步获取到的位置信息 PC存储位置(相对于命令行)\n\n\nPC 端文件(用户名文件下)\n\n","categories":["项目实践"],"tags":["Android"]},{"title":"代理模式","url":"/archives/7b510e10.html","content":"今天准备开发一个 SLO 的监控请求需求\n\n"},{"title":"常见古英语单词对照","url":"/archives/db3cdaed.html","content":"读十四行诗必备~\n\n\n\n\n\n古英语\n现代英语\n\n\n\nthou\n主格you\n\n\nthy\nyour\n\n\noft\noften\n\n\ntho’\nthough\n\n\nthine\nyours\n\n\nhither\nhere\n\n\nwi’\nwith\n\n\nhath\nhas\n\n\no’\nof\n\n\ndoth\ndoes\n\n\ne’en\neven\n\n\no’er\nover\n\n\nart\nare\n\n\nthee\n宾格you\n\n\n"},{"title":"思维导图工具学习使用","url":"/archives/b7d58f68.html","content":"思路导图工具 Xmind 的学习使用\n\n"},{"title":"计算机程序的构造和解释（SICP）学习","url":"/archives/bfe0c20.html","content":"学习一下编程神课（SICP）\n\n\n课上把编程语句分为两种陈述句和祈使句。DECLARATIVE VS IMPERATIVE\n重点在于 IMPERATIVE 怎么理解？\n释义：used to describe the form of a verb that is usually used for giving orders:\n\nimperative form In the phrase “Leave him alone!”, the verb “leave” is in the imperative form.\n\n语法中四大基础句式（顺便回顾下，加强联系）：\n\n陈述句：Declarative clauses most commonly function as statements. The usual word order is subject (s) + verb (v) + x. Declaratives can be affirmative or negative. They make statements about how things are and how they are not.\n祈使句：Imperative clauses most commonly function as commands, instructions or orders. The usual word order is verb + x. We do not usually include the subject in an imperative clause. We use the base form of the verb\n疑问句：Interrogative clauses most commonly function as questions. The usual word order is (wh-word) + auxiliary&#x2F;modal verb (aux&#x2F;m) + subject + verb + x\n感叹句：Exclamative clauses usually have one of the following word orders:\nWhat + noun + subject + verb\nHow + adjective or adverb + subject + verb\nAuxiliary or modal verb + subject + verb (i.e. interrogative word order)\n\n\n\n"},{"title":"设计模式","url":"/archives/364ea8cc.html","content":"学习优秀的编程范式\n\n\n《GoF Design Patterns》1984年第一次发版，讲设计模式统分为 3 大类型。\n\n创建型\n结构型\n行为型\n\n"},{"title":"软件开发原则","url":"/archives/23d7cb04.html","content":"以前写的程序很短视，只想着实现功能和效果，这样很不 nice，维护性没有保障!!! 学习一下软件开发中一些实践证明好用的指导 -_-\n\n\n开闭原则对扩展开放，对修改关闭\nKISSKeep It Simple, Stupid\nDRYDon’t Repeat Yourself\nYAGNIYou Aren’t Gonna Need It\n分离关注点Separation of Concerns\n里氏替换原则Liskov Substitution Principle 丽思珂芙女士 1987 年提出：继承必须确保超类所拥有的性质在子类中仍然成立。\n依赖倒置原则Dependency Inversion Principle Robert C.Martin 1996 年提出：抽象不应该依赖于细节，细节应该依赖于抽象。\n单一职责原则Single Responsibility Principle Robert C.Martin 提出：一个类应该只有一个引起它变化的原因。\n接口隔离原则Interface Segregation Principle Robert C.Martin 提出：一个类对另一个类的依赖应该建立在最小的接口之上。\n迪米特法则Law  of Demeter ：一个软件实体应当尽可能少地与其他实体发生相互作用。\n合成复用原则Composite Reuse Principle ：优先使用组合、聚合等关联关系，其次考虑使用继承并严格遵守里氏替换原则。\n"}]